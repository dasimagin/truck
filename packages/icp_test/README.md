❗️Файл тестовый, поэтому пока без рефактора, было важно проверить работоспособность алгоритма


### Алгоритм работы пакета:
1. Считывание двух файлов в облка точек
2. Инициализация алгоритма icp с помощью конфига
3. Поворот одного облака относительно другого
4. Вывод вектора $`v = ICP(cloud_1, cloud_2), v = (x, y, z, roll, pitch, yaw) \in R^6`$
5. Вывод ошибки (ResidualError)
6. Запись исходных облаков и повернутого в .mcap файл

###  Подробнее про [конфиг](https://github.com/robotics-laboratory/truck/blob/agkolomnikova-test/packages/icp_test/conf/icp_config.yaml)

#### Проблемы, с которыми столкнулись:
1. При запуске icp для одной и той же пары облаков [ошибка](https://github.com/robotics-laboratory/truck/blob/563ac15d2b89ac422f15432f2057068e4a0945cb/packages/icp_test/src/main.cpp#L118) выдавала разные значения - для этого нужно детерминировать конфиг секцию referenceDataPointsFilters (пока в работе)
2. Также [ошибка](https://github.com/robotics-laboratory/truck/blob/563ac15d2b89ac422f15432f2057068e4a0945cb/packages/icp_test/src/main.cpp#L118) выдавала большие значения на "хорошем" метчинге - решили выбрать определенный порог, превышая который ошибка будет давать понять, что облака точно склеились неудовлетворительно

#### Важные замечания по конфигу:
1. Используется метчинг без оси z, так как все облака находятся на одном уровне
2. Можно использовать разворот нормалей в центр фрейма (осталось понять, что указать в качестве центра)
3. Используется инспектор для визуализации работы алгоритма

### Дальнейший план на работу с g2o

#### Алгоритм работы g2o:
1. Формирование графа: Создание вершин и ребер на основе данных.
2. Определение функции ошибки: Для каждого ребра определяется функция ошибки, которая измеряет отклонение от ожидаемых значений.
3. Оптимизация: Использование выбранного алгоритма оптимизации для минимизации общей ошибки по всем ребрам.
4. Получение результатов: После завершения оптимизации параметры в вершинах графа обновляются.

#### Оптимизаторы

| Оптимизатор| Принцип работы | Преимущества | Недостатки|
|----------------------|----------------------------------|------------------|------------------|
| Levenberg-Marquardt  | Комбинирует градиентный спуск и метод Ньютона. | Высокая точность | Может быть медленным при больших задачах, также может плохо реагировать на шумы|
| Gauss-Newton | Игнорирует вторые производные; использует только первую производную.| Меньшая вычислительная сложность, хорошо для небольших наборов данных.|  Менее устойчивый, не всегда гарантирует глобальный минимум. |
| Dogleg | Комбинирует методы Гаусса-Ньютона и градиентного спуска, он использует два направления: одно от градиентного спуска, другое — от метода Гаусса-Ньютона, и выбирает между ними.| Высокая устойчивость, эффективен при шумных данных.  | Может быть медленнее Levenberg-Marquardt|

❗️Предлагаю попробовать использовать Dogleg, если для нас будет слишком медленно - вернемся к Levenberg-Marquardt

#### Задача на ближайшее время:

1. Написать функцию вычисления score (score_local(tf_clouds[i], tf_clouds[j] = доля точек из одного облака, которые нашли свои ближайшие соответствия в другом облаке на заданном расстоянии rad)
2. Интегрировать вычисление score в пакет lidar_map (считать до и после построения карты)
3. Вычислить mean, rmse, q90 для обоих подсчетов score






